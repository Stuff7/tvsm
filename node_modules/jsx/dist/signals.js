const context = [];
function watch(fn) {
  const execute = (value) => {
    cleanup(running);
    context.push(running);
    try {
      fn(value);
    } finally {
      context.pop();
    }
  };
  const running = {
    execute,
    dependencies: /* @__PURE__ */ new Set()
  };
  execute(void 0);
  return running;
}
function watchOnly(deps, fn) {
  const execute = (value) => {
    cleanup(running);
    deps.forEach((dep) => {
      subscribe(running, dep.listeners);
    });
    try {
      fn(value);
    } finally {
      context.pop();
    }
  };
  const running = {
    execute,
    dependencies: /* @__PURE__ */ new Set()
  };
  execute(void 0);
  return running;
}
function watchFn(deps, fn) {
  const execute = (value) => {
    cleanup(running);
    context.push(running);
    try {
      deps();
    } finally {
      context.pop();
    }
    try {
      fn(value);
    } finally {
      context.pop();
    }
  };
  const running = {
    execute,
    dependencies: /* @__PURE__ */ new Set()
  };
  execute(void 0);
  return running;
}
function ref(value = void 0) {
  const listeners = /* @__PURE__ */ new Set();
  let v = value;
  const get = () => {
    const running = context[context.length - 1];
    if (running) {
      subscribe(running, listeners);
    }
    return v;
  };
  const set = (newV) => {
    const prev = v;
    v = newV;
    for (const sub of [...listeners]) {
      sub.execute(prev);
    }
  };
  return [
    Object.assign(get, { listeners }),
    Object.assign(
      set,
      {
        byRef: (mutFn) => {
          mutFn(v);
          set(v);
        },
        byRefAsync: async (mutFn) => {
          await mutFn(v);
          set(v);
        }
      }
    )
  ];
}
function reactive(objValue) {
  const obj = objValue;
  Object.defineProperty(obj, "listeners", {
    value: /* @__PURE__ */ new Set(),
    enumerable: false,
    configurable: true
  });
  for (const k in obj) {
    let v = obj[k];
    Object.defineProperty(obj, k, {
      get: () => {
        const running = context[context.length - 1];
        if (running) {
          subscribe(running, obj.listeners);
        }
        return v;
      },
      set: (newV) => {
        const prev = v;
        v = newV;
        for (const sub of [...obj.listeners]) {
          sub.execute(prev);
        }
      }
    });
  }
  return obj;
}
function isReactiveObject(value) {
  return "listeners" in value && value.listeners instanceof Set;
}
function subscribe(running, subscriptions) {
  subscriptions.add(running);
  running.dependencies.add(subscriptions);
}
function cleanup(running) {
  for (const dep of running.dependencies) {
    dep.delete(running);
  }
  running.dependencies.clear();
}
function isBoolAttribute(value) {
  return typeof value === "string" || typeof value === "boolean";
}
export {
  cleanup,
  isBoolAttribute,
  isReactiveObject,
  reactive,
  ref,
  watch,
  watchFn,
  watchOnly
};
//# sourceMappingURL=signals.js.map
