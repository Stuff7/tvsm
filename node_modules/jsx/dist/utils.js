function reverseForEach(arr, cb) {
  arr.findLast(cb);
}
function swapRemove(a, i) {
  a[i] = a[a.length - 1];
  a.length--;
}
function swap(arr, idx1, idx2) {
  [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
}
function arrLast(arr) {
  return arr[arr.length - 1];
}
function deepEq(a, b) {
  const keys1 = Object.keys(a);
  const keys2 = Object.keys(b);
  const allKeys = /* @__PURE__ */ new Set([...keys1, ...keys2]);
  for (const key of allKeys) {
    const aV = a[key];
    const bV = b[key];
    if (typeof aV === "object" && typeof bV === "object") {
      if (aV instanceof Date && bV instanceof Date) {
        if (aV.getTime() !== bV.getTime()) {
          return false;
        }
      } else if (aV instanceof Map && bV instanceof Map) {
        if (aV.size !== bV.size) {
          return false;
        }
        for (const [key2, value] of aV) {
          if (!bV.has(key2) || bV.get(key2) !== value) {
            return false;
          }
        }
      } else if (aV instanceof Set && bV instanceof Set) {
        if (aV.size !== bV.size) {
          return false;
        }
        for (const item of aV) {
          if (!bV.has(item)) {
            return false;
          }
        }
      } else if (!deepEq(aV, bV)) {
        return false;
      }
    } else if (aV !== bV) {
      return false;
    }
  }
  return true;
}
function iterChildrenDeep(node, fn) {
  if (node.nodeType === node.ELEMENT_NODE) {
    for (const c of node.getElementsByTagName("*")) {
      fn(c);
    }
  }
  fn(node);
}
function iterChildNodesDeep(node, fn) {
  fn(node);
  for (const n of node.childNodes) {
    iterChildNodesDeep(n, fn);
  }
  node.remove();
}
function createElementPosition(elem) {
  const self = {
    parent: null,
    prevSibling: null,
    nextSibling: null,
    setFromElement(element) {
      this.parent = element.parentElement;
      this.prevSibling = element.previousSibling;
      this.nextSibling = element.nextSibling;
    },
    isPositioned() {
      return !!(this.parent || this.prevSibling || this.nextSibling);
    },
    getInsertFunction() {
      if (this.prevSibling && this.prevSibling.parentElement) {
        return this.prevSibling.after.bind(this.prevSibling);
      }
      if (this.nextSibling && this.nextSibling.parentElement) {
        return this.nextSibling.before.bind(this.nextSibling);
      }
      if (this.parent) {
        if (this.nextSibling) {
          return this.parent.prepend.bind(this.parent);
        }
        return this.parent.append.bind(this.parent);
      }
      throw new Error("Could not find element position");
    },
    insertNode(...nodes) {
      try {
        this.getInsertFunction()(...nodes);
        return true;
      } catch (_) {
        return false;
      }
    }
  };
  if (elem) {
    queueMicrotask(() => self.setFromElement(elem));
  }
  return self;
}
export {
  arrLast,
  createElementPosition,
  deepEq,
  iterChildNodesDeep,
  iterChildrenDeep,
  reverseForEach,
  swap,
  swapRemove
};
//# sourceMappingURL=utils.js.map
