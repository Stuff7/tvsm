{
  "version": 3,
  "sources": ["../js/signals.ts"],
  "sourcesContent": ["const context = [] as Running<never>[];\n\nexport type Running<T> = {\n  execute(value: T): void;\n  dependencies: Set<Listeners<T>>;\n};\n\ntype Listeners<T> = Set<Running<T>>;\n\nexport type Reactive<T> = T & {\n  listeners: Listeners<T>,\n};\n\nexport type Ref<T> = [\n  get: (() => T) & { listeners: Listeners<T> },\n  set: ((v: T) => void) & {\n    byRef: (mutFn: (currentV: T) => void) => void;\n    byRefAsync: (mutFn: (currentV: T) => Promise<void>) => Promise<void>;\n  },\n];\n\nexport type BoolAttr = boolean | \"true\" | \"false\";\n\nexport type ReactiveAttr = Ref<string> | Ref<boolean> | string | boolean;\n\nexport function watch<T>(fn: Running<T>[\"execute\"]) {\n  const execute: Running<T>[\"execute\"] = (value) => {\n    cleanup(running);\n    context.push(running);\n    try {\n      fn(value);\n    }\n    finally {\n      context.pop();\n    }\n  };\n\n  const running: Running<T> = {\n    execute,\n    dependencies: new Set(),\n  };\n\n  execute(undefined as T);\n\n  return running;\n}\n\n/**\n * Works like `watch` but it only subscribes to the specified dependencies (deps)\n * and ignores any other accesses from within the callback (fn).\n * */\nexport function watchOnly<T>(deps: ({ listeners: Listeners<unknown> })[], fn: Running<T>[\"execute\"]) {\n  const execute: Running<T>[\"execute\"] = (value) => {\n    cleanup(running);\n\n    deps.forEach(dep => {\n      subscribe(running, dep.listeners);\n    });\n\n    try {\n      fn(value);\n    }\n    finally {\n      context.pop();\n    }\n  };\n\n  const running: Running<T> = {\n    execute,\n    dependencies: new Set(),\n  };\n\n  execute(undefined as T);\n\n  return running;\n}\n\n/**\n * Works like `watchOnly` but only watches the dependencies used in `depsFn`.\n * */\nexport function watchFn<T>(deps: () => unknown, fn: Running<T>[\"execute\"]) {\n  const execute: Running<T>[\"execute\"] = (value) => {\n    cleanup(running);\n    context.push(running);\n\n    try {\n      deps();\n    }\n    finally {\n      context.pop();\n    }\n\n    try {\n      fn(value);\n    }\n    finally {\n      context.pop();\n    }\n  };\n\n  const running: Running<T> = {\n    execute,\n    dependencies: new Set(),\n  };\n\n  execute(undefined as T);\n\n  return running;\n}\n\nexport function ref<T>(value: T = undefined as T): Ref<T> {\n  const listeners: Listeners<T> = new Set;\n  let v = value;\n\n  const get = () => {\n    const running = context[context.length - 1];\n    if (running) { subscribe(running, listeners) }\n    return v;\n  };\n\n  const set = (newV: T) => {\n    const prev = v;\n    v = newV;\n\n    for (const sub of [...listeners]) {\n      sub.execute(prev);\n    }\n  };\n\n  return [\n    Object.assign(get, { listeners }),\n    Object.assign(\n      set,\n      {\n        byRef: (mutFn: (currentV: T) => void) => {\n          mutFn(v);\n          set(v);\n        },\n        byRefAsync: async (mutFn: (currentV: T) => Promise<void>) => {\n          await mutFn(v);\n          set(v);\n        },\n      },\n    ),\n  ];\n}\n\nexport function reactive<T extends object>(objValue: T): Reactive<T> {\n  const obj = objValue as Reactive<T>;\n  Object.defineProperty(obj, \"listeners\", {\n    value: new Set(),\n    enumerable: false,\n    configurable: true,\n  });\n\n  for (const k in obj) {\n    let v = obj[k];\n    Object.defineProperty(obj, k, {\n      get: () => {\n        const running = context[context.length - 1];\n        if (running) { subscribe(running, obj.listeners) }\n        return v;\n      },\n      set: (newV) => {\n        const prev = v;\n        v = newV;\n        for (const sub of [...obj.listeners]) {\n          sub.execute(prev);\n        }\n      },\n    });\n  }\n\n  return obj;\n}\n\nexport function isReactiveObject<T extends object>(value: T): value is Reactive<T> {\n  return \"listeners\" in value && value.listeners instanceof Set;\n}\n\nfunction subscribe<T>(running: Running<T>, subscriptions: Listeners<T>) {\n  subscriptions.add(running);\n  running.dependencies.add(subscriptions);\n}\n\nexport function cleanup<T>(running: Running<T>) {\n  for (const dep of running.dependencies) {\n    dep.delete(running);\n  }\n  running.dependencies.clear();\n}\n\nexport function isBoolAttribute(value: unknown): value is BoolAttr {\n  return typeof value === \"string\" || typeof value === \"boolean\";\n}\n"],
  "mappings": "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",
  "names": []
}
