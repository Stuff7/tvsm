{
  "version": 3,
  "sources": ["../../js/components/For.tsx"],
  "sourcesContent": ["import { destroyNode } from \"~/jsx\";\nimport { isReactiveObject, reactive, ref, watch } from \"~/signals\";\nimport { createElementPosition, InsertNodeFn } from \"~/utils\";\n\ntype ForProps<T> = {\n  each: T[],\n  do: (item: () => T, i: number) => JSX.Element,\n};\n\n/**\n * A component that renders a list of JSX elements from a reactive dynamically-sized array.\n * Elements are keyed by reference, meaning nodes will only be re-created when the actual\n * object in the array changes.\n *\n * @note Use `<FixedFor>` if you need to render a fixed-size array, as this component is\n * optimized for dynamic arrays that can change in size.\n */\nexport default function For<T>(props: ForProps<T>): JSX.Element {\n  const initialPosition = createElementPosition();\n  const anchor = document.createComment(\"For\");\n\n  const refs: T[] = [];\n  const list = props.each.map(createNode);\n  let length = props.each.length;\n\n  queueMicrotask(() => {\n    if (!anchor.isConnected && !anchor.parentElement) {\n      console.warn(\"<For> failed to mount\");\n    }\n    initialPosition.setFromElement(anchor);\n    anchor.remove();\n    list.forEach((n, i) => {\n      const lastElem = list[i - 1];\n      let insertNode: InsertNodeFn;\n\n      if (lastElem?.isConnected) {\n        insertNode = lastElem.after.bind(lastElem);\n      }\n      else {\n        insertNode = initialPosition.getInsertFunction();\n      }\n\n      return insertNode(n);\n    });\n  });\n\n  function createNode(data: T, i: number) {\n    const [item, setItem] = ref(data);\n\n    const currentItem = item();\n    if (currentItem && typeof currentItem === \"object\") {\n      if (isReactiveObject(currentItem)) {\n        currentItem.listeners.clear();\n      }\n      else {\n        reactive(currentItem);\n      }\n    }\n\n    let removed = false;\n    watch(() => {\n      if (removed) { return }\n\n      const newItem = props.each[i];\n      if (newItem && typeof newItem === \"object\" && !isReactiveObject(newItem)) {\n        reactive(newItem);\n      }\n\n      if (item() !== newItem) {\n        refs[i] = newItem;\n        if (newItem === undefined) {\n          removed = true;\n          removeNode();\n        }\n        else {\n          setItem(newItem);\n        }\n      }\n    });\n\n    refs.push(item());\n\n    return props.do(item, i);\n  }\n\n  function removeNode() {\n    if (props.each.length < length) {\n      if (refs[length - 1] !== undefined) { return }\n      for (let i = length - 1; i >= props.each.length; i--) {\n        destroyNode(list[i]);\n      }\n      length = refs.length = list.length = props.each.length;\n    }\n  }\n\n  watch(() => {\n    if (props.each.length > length) {\n      for (let i = length; i < props.each.length; i++) {\n        const lastElem = list[i - 1];\n\n        let insertNode: InsertNodeFn;\n        if (lastElem?.isConnected) {\n          insertNode = lastElem.after.bind(lastElem);\n        }\n        else {\n          insertNode = initialPosition.getInsertFunction();\n        }\n\n        const node = createNode(props.each[i], i);\n        insertNode(node);\n        list.push(node);\n      }\n\n      length = refs.length = list.length = props.each.length;\n    }\n    else if (props.each.length < length) {\n      removeNode();\n    }\n  });\n\n  return anchor as unknown as JSX.Element;\n}\n"],
  "mappings": "AAAA,SAAS,mBAAmB;AAC5B,SAAS,kBAAkB,UAAU,KAAK,aAAa;AACvD,SAAS,6BAA2C;AAerC,SAAR,IAAwB,OAAiC;AAC9D,QAAM,kBAAkB,sBAAsB;AAC9C,QAAM,SAAS,SAAS,cAAc,KAAK;AAE3C,QAAM,OAAY,CAAC;AACnB,QAAM,OAAO,MAAM,KAAK,IAAI,UAAU;AACtC,MAAI,SAAS,MAAM,KAAK;AAExB,iBAAe,MAAM;AACnB,QAAI,CAAC,OAAO,eAAe,CAAC,OAAO,eAAe;AAChD,cAAQ,KAAK,uBAAuB;AAAA,IACtC;AACA,oBAAgB,eAAe,MAAM;AACrC,WAAO,OAAO;AACd,SAAK,QAAQ,CAAC,GAAG,MAAM;AACrB,YAAM,WAAW,KAAK,IAAI,CAAC;AAC3B,UAAI;AAEJ,UAAI,UAAU,aAAa;AACzB,qBAAa,SAAS,MAAM,KAAK,QAAQ;AAAA,MAC3C,OACK;AACH,qBAAa,gBAAgB,kBAAkB;AAAA,MACjD;AAEA,aAAO,WAAW,CAAC;AAAA,IACrB,CAAC;AAAA,EACH,CAAC;AAED,WAAS,WAAW,MAAS,GAAW;AACtC,UAAM,CAAC,MAAM,OAAO,IAAI,IAAI,IAAI;AAEhC,UAAM,cAAc,KAAK;AACzB,QAAI,eAAe,OAAO,gBAAgB,UAAU;AAClD,UAAI,iBAAiB,WAAW,GAAG;AACjC,oBAAY,UAAU,MAAM;AAAA,MAC9B,OACK;AACH,iBAAS,WAAW;AAAA,MACtB;AAAA,IACF;AAEA,QAAI,UAAU;AACd,UAAM,MAAM;AACV,UAAI,SAAS;AAAE;AAAA,MAAO;AAEtB,YAAM,UAAU,MAAM,KAAK,CAAC;AAC5B,UAAI,WAAW,OAAO,YAAY,YAAY,CAAC,iBAAiB,OAAO,GAAG;AACxE,iBAAS,OAAO;AAAA,MAClB;AAEA,UAAI,KAAK,MAAM,SAAS;AACtB,aAAK,CAAC,IAAI;AACV,YAAI,YAAY,QAAW;AACzB,oBAAU;AACV,qBAAW;AAAA,QACb,OACK;AACH,kBAAQ,OAAO;AAAA,QACjB;AAAA,MACF;AAAA,IACF,CAAC;AAED,SAAK,KAAK,KAAK,CAAC;AAEhB,WAAO,MAAM,GAAG,MAAM,CAAC;AAAA,EACzB;AAEA,WAAS,aAAa;AACpB,QAAI,MAAM,KAAK,SAAS,QAAQ;AAC9B,UAAI,KAAK,SAAS,CAAC,MAAM,QAAW;AAAE;AAAA,MAAO;AAC7C,eAAS,IAAI,SAAS,GAAG,KAAK,MAAM,KAAK,QAAQ,KAAK;AACpD,oBAAY,KAAK,CAAC,CAAC;AAAA,MACrB;AACA,eAAS,KAAK,SAAS,KAAK,SAAS,MAAM,KAAK;AAAA,IAClD;AAAA,EACF;AAEA,QAAM,MAAM;AACV,QAAI,MAAM,KAAK,SAAS,QAAQ;AAC9B,eAAS,IAAI,QAAQ,IAAI,MAAM,KAAK,QAAQ,KAAK;AAC/C,cAAM,WAAW,KAAK,IAAI,CAAC;AAE3B,YAAI;AACJ,YAAI,UAAU,aAAa;AACzB,uBAAa,SAAS,MAAM,KAAK,QAAQ;AAAA,QAC3C,OACK;AACH,uBAAa,gBAAgB,kBAAkB;AAAA,QACjD;AAEA,cAAM,OAAO,WAAW,MAAM,KAAK,CAAC,GAAG,CAAC;AACxC,mBAAW,IAAI;AACf,aAAK,KAAK,IAAI;AAAA,MAChB;AAEA,eAAS,KAAK,SAAS,KAAK,SAAS,MAAM,KAAK;AAAA,IAClD,WACS,MAAM,KAAK,SAAS,QAAQ;AACnC,iBAAW;AAAA,IACb;AAAA,EACF,CAAC;AAED,SAAO;AACT;",
  "names": []
}
